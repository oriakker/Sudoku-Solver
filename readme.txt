I have used a combination of constraint propagation, a minimum remaining value heuristic and a backtrack search to efficiently and quickly solve the sudoku problems. I quickly realised a simple stand-alone backtrack search would not be efficient enough to solve hard sudokus as there are too many empty squares to search through and constraint propagation alone would not be effective either as there were not enough given values to propagate other values from.  

I began my code by writing some simple functions that grouped together the rows, columns and 3x3 grids of the sudoku. I used these functions to write another function that establishes all of the neighbouring squares in the same row, column and grid as a given square. I could then calculate the possible values for each square by eliminating values that were already present in it's neighbouring squares. My get_values() function finds these potential values and stores them in a dictionary (where each square's address, [row,col], is the key to an array containing it's possible values) as this dictionary format is efficient in both storage and access.

With this dictionary of possible values for each squares, I used two method of constraint propagation to further solve the sudoku. My first method propagated values by assigning a value to any square with only one possible value and re-calculating the values dictionary after this assignment. My second method assigned a value to any row, column or grid if there was only one possible place for this value within the relevant row, column or grid. I also wrote a third function that combined these two methods into one function, allowing easier access to these methods during the backtrack search.

I also wrote a minimum remaining value function that locates the square in a given sudoku that has the least possible values. This function is used in the backtrack search to minimise the number of backtracks required. It is clearly much more efficient to only have to check three possible values for an empty square rather than having to check seven, especially if there is no solution to the sudoku.

I also wrote some functions to check the validity of certain sudoku states; the first function checks if a sudoku is valid, the second checks if a sudoku is solved and the third checks if assigning a certain value to a sudoku is a valid move. This third function uses a deep copy of the sudoku to forward check the validity using constraint propagation and as such, maximises the efficiency of the backtrack search by more rapidly ruling out invalid sudoku states. 

Finally, I wrote a backtrack search function that ties together all of the other functions to find a solution (or find that there is no valid solution) to the given sudoku problem. The backtrack search begins by returning true if there are no empty squares, as clearly a solution has been found. If unsolved, the function then finds the square with least possible values for the input sudoku, and iterates through the possible values by assigning them one-by-one. If this assignment is invalid or the constraint propagation returns an invalid state, then the function moves on to the next possible value for the square. If it is a valid move and the constraint propagation is valid, the backtrack search is recursively called on this sudoku with its propagated values and the squares that were edited during the propagation are saved within each recursive call. If the backtrack search returns true then the solution has been found. However, if it returns false, then a backtrack is triggered. The values assigned during the last constraint propagation are removed from the sudoku alongside the value assigned during the last call of the for loop. The for loop then runs its next iteration - assigning the next possible value. This continues until either a solution is found, or the function returns false overall, implying that there is no possible solution to the initial sudoku. If this is the case, the sudoku_solver() function returns a sudoku with all entries set to -1. The sudoku_solver() function also returns this -1 sudoku if the input sudoku itself is an invalid state. If the backtrack search does find a solution, then the sudoku_solver() function returns this solution state.



